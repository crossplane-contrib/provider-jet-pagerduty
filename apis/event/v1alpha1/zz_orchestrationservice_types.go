/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionsAutomationActionObservation struct {
}

type ActionsAutomationActionParameters struct {

	// When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
	// +kubebuilder:validation:Optional
	AutoSend *bool `json:"autoSend,omitempty" tf:"auto_send,omitempty"`

	// Specify custom key/value pairs that'll be sent with the webhook request as request headers.
	// +kubebuilder:validation:Optional
	Header []AutomationActionHeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// Name of this Webhook.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
	// +kubebuilder:validation:Optional
	Parameter []AutomationActionParameterParameters `json:"parameter,omitempty" tf:"parameter,omitempty"`

	// The API endpoint where PagerDuty's servers will send the webhook request.
	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`
}

type ActionsExtractionObservation struct {
}

type ActionsExtractionParameters struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	// +kubebuilder:validation:Required
	Target *string `json:"target" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	// +kubebuilder:validation:Optional
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type ActionsPagerdutyAutomationActionObservation struct {
}

type ActionsPagerdutyAutomationActionParameters struct {

	// Id of the Process Automation action to be triggered.
	// +kubebuilder:validation:Required
	ActionID *string `json:"actionId" tf:"action_id,omitempty"`
}

type ActionsVariableObservation struct {
}

type ActionsVariableParameters struct {

	// Name of this Webhook.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data. You can use any valid PCL path.
	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// Only regex is supported
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Value of this header
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AutomationActionHeaderObservation struct {
}

type AutomationActionHeaderParameters struct {

	// Name to identify the header
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Value of this header
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AutomationActionObservation struct {
}

type AutomationActionParameterObservation struct {
}

type AutomationActionParameterParameters struct {

	// Name to identify the header
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Value of this header
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AutomationActionParameters struct {

	// When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
	// +kubebuilder:validation:Optional
	AutoSend *bool `json:"autoSend,omitempty" tf:"auto_send,omitempty"`

	// Specify custom key/value pairs that'll be sent with the webhook request as request headers.
	// +kubebuilder:validation:Optional
	Header []HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// Name of this Webhook.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
	// +kubebuilder:validation:Optional
	Parameter []ParameterParameters `json:"parameter,omitempty" tf:"parameter,omitempty"`

	// The API endpoint where PagerDuty's servers will send the webhook request.
	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`
}

type CatchAllActionsObservation struct {
}

type CatchAllActionsParameters struct {

	// Add this text as a note on the resulting incident.
	// +kubebuilder:validation:Optional
	Annotate *string `json:"annotate,omitempty" tf:"annotate,omitempty"`

	// Create a Webhook associated with the resulting incident.
	// +kubebuilder:validation:Optional
	AutomationAction []AutomationActionParameters `json:"automationAction,omitempty" tf:"automation_action,omitempty"`

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	// +kubebuilder:validation:Optional
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	// +kubebuilder:validation:Optional
	Extraction []ExtractionParameters `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// Configure a Process Automation associated with the resulting incident.
	// +kubebuilder:validation:Optional
	PagerdutyAutomationAction []PagerdutyAutomationActionParameters `json:"pagerdutyAutomationAction,omitempty" tf:"pagerduty_automation_action,omitempty"`

	// The ID of the priority you want to set on resulting incident. Consider using the pagerduty_priority data source.
	// +kubebuilder:validation:Optional
	Priority *string `json:"priority,omitempty" tf:"priority,omitempty"`

	// The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
	// +kubebuilder:validation:Optional
	RouteTo *string `json:"routeTo,omitempty" tf:"route_to,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	// +kubebuilder:validation:Optional
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
	// +kubebuilder:validation:Optional
	Suppress *bool `json:"suppress,omitempty" tf:"suppress,omitempty"`

	// The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a resolve event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
	// +kubebuilder:validation:Optional
	Suspend *float64 `json:"suspend,omitempty" tf:"suspend,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	// +kubebuilder:validation:Optional
	Variable []VariableParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type ExtractionObservation struct {
}

type ExtractionParameters struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	// +kubebuilder:validation:Required
	Target *string `json:"target" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	// +kubebuilder:validation:Optional
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type HeaderObservation struct {
}

type HeaderParameters struct {

	// Name to identify the header
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Value of this header
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type OrchestrationServiceCatchAllObservation struct {
}

type OrchestrationServiceCatchAllParameters struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	// +kubebuilder:validation:Required
	Actions []CatchAllActionsParameters `json:"actions" tf:"actions,omitempty"`
}

type OrchestrationServiceObservation struct {

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A Service Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	// +kubebuilder:validation:Required
	Set []OrchestrationServiceSetObservation `json:"set,omitempty" tf:"set,omitempty"`
}

type OrchestrationServiceParameters struct {

	// the catch_all actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	// +kubebuilder:validation:Required
	CatchAll []OrchestrationServiceCatchAllParameters `json:"catchAll" tf:"catch_all,omitempty"`

	// ID of the Service to which this Service Orchestration belongs to.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-pagerduty/apis/service/v1alpha1.Service
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a Service in service to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a Service in service to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// A Service Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	// +kubebuilder:validation:Required
	Set []OrchestrationServiceSetParameters `json:"set" tf:"set,omitempty"`
}

type OrchestrationServiceSetObservation struct {

	// The service orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions.
	// +kubebuilder:validation:Optional
	Rule []SetRuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`
}

type OrchestrationServiceSetParameters struct {

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// The service orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions.
	// +kubebuilder:validation:Optional
	Rule []SetRuleParameters `json:"rule,omitempty" tf:"rule,omitempty"`
}

type PagerdutyAutomationActionObservation struct {
}

type PagerdutyAutomationActionParameters struct {

	// Id of the Process Automation action to be triggered.
	// +kubebuilder:validation:Required
	ActionID *string `json:"actionId" tf:"action_id,omitempty"`
}

type ParameterObservation struct {
}

type ParameterParameters struct {

	// Name to identify the header
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Value of this header
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type RuleConditionObservation struct {
}

type RuleConditionParameters struct {

	// A PCL condition string.
	// +kubebuilder:validation:Required
	Expression *string `json:"expression" tf:"expression,omitempty"`
}

type SetRuleActionsObservation struct {
}

type SetRuleActionsParameters struct {

	// Add this text as a note on the resulting incident.
	// +kubebuilder:validation:Optional
	Annotate *string `json:"annotate,omitempty" tf:"annotate,omitempty"`

	// Create a Webhook associated with the resulting incident.
	// +kubebuilder:validation:Optional
	AutomationAction []ActionsAutomationActionParameters `json:"automationAction,omitempty" tf:"automation_action,omitempty"`

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	// +kubebuilder:validation:Optional
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	// +kubebuilder:validation:Optional
	Extraction []ActionsExtractionParameters `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// Configure a Process Automation associated with the resulting incident.
	// +kubebuilder:validation:Optional
	PagerdutyAutomationAction []ActionsPagerdutyAutomationActionParameters `json:"pagerdutyAutomationAction,omitempty" tf:"pagerduty_automation_action,omitempty"`

	// The ID of the priority you want to set on resulting incident. Consider using the pagerduty_priority data source.
	// +kubebuilder:validation:Optional
	Priority *string `json:"priority,omitempty" tf:"priority,omitempty"`

	// The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
	// +kubebuilder:validation:Optional
	RouteTo *string `json:"routeTo,omitempty" tf:"route_to,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	// +kubebuilder:validation:Optional
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
	// +kubebuilder:validation:Optional
	Suppress *bool `json:"suppress,omitempty" tf:"suppress,omitempty"`

	// The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a resolve event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
	// +kubebuilder:validation:Optional
	Suspend *float64 `json:"suspend,omitempty" tf:"suspend,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	// +kubebuilder:validation:Optional
	Variable []ActionsVariableParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type SetRuleObservation struct {

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SetRuleParameters struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	// +kubebuilder:validation:Required
	Actions []SetRuleActionsParameters `json:"actions" tf:"actions,omitempty"`

	// Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will always match against the rule.
	// +kubebuilder:validation:Optional
	Condition []RuleConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// Indicates whether the rule is disabled and would therefore not be evaluated.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// A description of this rule's purpose.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type VariableObservation struct {
}

type VariableParameters struct {

	// Name of this Webhook.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data. You can use any valid PCL path.
	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// Only regex is supported
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Value of this header
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// OrchestrationServiceSpec defines the desired state of OrchestrationService
type OrchestrationServiceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OrchestrationServiceParameters `json:"forProvider"`
}

// OrchestrationServiceStatus defines the observed state of OrchestrationService.
type OrchestrationServiceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OrchestrationServiceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// OrchestrationService is the Schema for the OrchestrationServices API. Creates and manages a Service Orchestration for a Service.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,pagerduty}
type OrchestrationService struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              OrchestrationServiceSpec   `json:"spec"`
	Status            OrchestrationServiceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OrchestrationServiceList contains a list of OrchestrationServices
type OrchestrationServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OrchestrationService `json:"items"`
}

// Repository type metadata.
var (
	OrchestrationService_Kind             = "OrchestrationService"
	OrchestrationService_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OrchestrationService_Kind}.String()
	OrchestrationService_KindAPIVersion   = OrchestrationService_Kind + "." + CRDGroupVersion.String()
	OrchestrationService_GroupVersionKind = CRDGroupVersion.WithKind(OrchestrationService_Kind)
)

func init() {
	SchemeBuilder.Register(&OrchestrationService{}, &OrchestrationServiceList{})
}
