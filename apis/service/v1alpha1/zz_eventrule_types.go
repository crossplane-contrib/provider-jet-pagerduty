/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionsObservation struct {
}

type ActionsParameters struct {

	// +kubebuilder:validation:Optional
	Annotate []AnnotateParameters `json:"annotate,omitempty" tf:"annotate,omitempty"`

	// +kubebuilder:validation:Optional
	EventAction []EventActionParameters `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// +kubebuilder:validation:Optional
	Extractions []ExtractionsParameters `json:"extractions,omitempty" tf:"extractions,omitempty"`

	// +kubebuilder:validation:Optional
	Priority []PriorityParameters `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	Severity []SeverityParameters `json:"severity,omitempty" tf:"severity,omitempty"`

	// +kubebuilder:validation:Optional
	Suppress []SuppressParameters `json:"suppress,omitempty" tf:"suppress,omitempty"`

	// +kubebuilder:validation:Optional
	Suspend []SuspendParameters `json:"suspend,omitempty" tf:"suspend,omitempty"`
}

type ActiveBetweenObservation struct {
}

type ActiveBetweenParameters struct {

	// +kubebuilder:validation:Optional
	EndTime *float64 `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// +kubebuilder:validation:Optional
	StartTime *float64 `json:"startTime,omitempty" tf:"start_time,omitempty"`
}

type AnnotateObservation struct {
}

type AnnotateParameters struct {

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionsObservation struct {
}

type ConditionsParameters struct {

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Subconditions []SubconditionsParameters `json:"subconditions,omitempty" tf:"subconditions,omitempty"`
}

type EventActionObservation struct {
}

type EventActionParameters struct {

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type EventRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type EventRuleParameters struct {

	// +kubebuilder:validation:Optional
	Actions []ActionsParameters `json:"actions,omitempty" tf:"actions,omitempty"`

	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// +kubebuilder:validation:Optional
	Position *float64 `json:"position,omitempty" tf:"position,omitempty"`

	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// +kubebuilder:validation:Optional
	TimeFrame []TimeFrameParameters `json:"timeFrame,omitempty" tf:"time_frame,omitempty"`

	// +kubebuilder:validation:Optional
	Variable []VariableParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type ExtractionsObservation struct {
}

type ExtractionsParameters struct {

	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Optional
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type ParameterObservation struct {
}

type ParameterParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ParametersObservation struct {
}

type ParametersParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PriorityObservation struct {
}

type PriorityParameters struct {

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ScheduledWeeklyObservation struct {
}

type ScheduledWeeklyParameters struct {

	// +kubebuilder:validation:Optional
	Duration *float64 `json:"duration,omitempty" tf:"duration,omitempty"`

	// +kubebuilder:validation:Optional
	StartTime *float64 `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`

	// +kubebuilder:validation:Optional
	Weekdays []*float64 `json:"weekdays,omitempty" tf:"weekdays,omitempty"`
}

type SeverityObservation struct {
}

type SeverityParameters struct {

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SubconditionsObservation struct {
}

type SubconditionsParameters struct {

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Parameter []ParameterParameters `json:"parameter,omitempty" tf:"parameter,omitempty"`
}

type SuppressObservation struct {
}

type SuppressParameters struct {

	// +kubebuilder:validation:Optional
	ThresholdTimeAmount *float64 `json:"thresholdTimeAmount,omitempty" tf:"threshold_time_amount,omitempty"`

	// +kubebuilder:validation:Optional
	ThresholdTimeUnit *string `json:"thresholdTimeUnit,omitempty" tf:"threshold_time_unit,omitempty"`

	// +kubebuilder:validation:Optional
	ThresholdValue *float64 `json:"thresholdValue,omitempty" tf:"threshold_value,omitempty"`

	// +kubebuilder:validation:Optional
	Value *bool `json:"value,omitempty" tf:"value,omitempty"`
}

type SuspendObservation struct {
}

type SuspendParameters struct {

	// +kubebuilder:validation:Optional
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type TimeFrameObservation struct {
}

type TimeFrameParameters struct {

	// +kubebuilder:validation:Optional
	ActiveBetween []ActiveBetweenParameters `json:"activeBetween,omitempty" tf:"active_between,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduledWeekly []ScheduledWeeklyParameters `json:"scheduledWeekly,omitempty" tf:"scheduled_weekly,omitempty"`
}

type VariableObservation struct {
}

type VariableParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Parameters []ParametersParameters `json:"parameters,omitempty" tf:"parameters,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

// EventRuleSpec defines the desired state of EventRule
type EventRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EventRuleParameters `json:"forProvider"`
}

// EventRuleStatus defines the observed state of EventRule.
type EventRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EventRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// EventRule is the Schema for the EventRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,pagerdutyjet}
type EventRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EventRuleSpec   `json:"spec"`
	Status            EventRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EventRuleList contains a list of EventRules
type EventRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EventRule `json:"items"`
}

// Repository type metadata.
var (
	EventRule_Kind             = "EventRule"
	EventRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: EventRule_Kind}.String()
	EventRule_KindAPIVersion   = EventRule_Kind + "." + CRDGroupVersion.String()
	EventRule_GroupVersionKind = CRDGroupVersion.WithKind(EventRule_Kind)
)

func init() {
	SchemeBuilder.Register(&EventRule{}, &EventRuleList{})
}
